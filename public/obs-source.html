<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiBot OBS Browser Source</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 1920px;
            height: 1080px;
            position: relative;
        }

        /* Status indicator - hidden by default, only show on errors */
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        
        /* Only show status when disconnected or error */
        #status.disconnected,
        #status.error {
            display: block;
        }

        #status.connected {
            background: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        #status.disconnected {
            background: rgba(255, 0, 0, 0.3);
            color: #ff0000;
        }

        #status.connecting {
            background: rgba(255, 255, 0, 0.3);
            color: #ffff00;
        }

        /* Hidden audio elements container */
        #audio-container {
            display: none;
        }

        /* Visual feedback (optional - can be enabled) */
        .command-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 999;
        }

        .command-feedback.show {
            opacity: 1;
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>
    <!-- Status indicator -->
    <div id="status" class="connecting">Connecting...</div>

    <!-- Visual feedback container -->
    <div id="command-feedback" class="command-feedback"></div>

    <!-- Audio container (hidden) -->
    <div id="audio-container"></div>

    <!-- Design elements container -->
    <div id="design-container" style="position: absolute; top: 0; left: 0; width: 1920px; height: 1080px; pointer-events: none; z-index: 1; overflow: visible;"></div>

    <script>
        // Get token from URL - handle both URLSearchParams and direct string extraction
        let token = null;
        
        // First, try to get token from server-replaced placeholder (most reliable)
        // Server replaces {{TOKEN}} with actual token value
        const serverToken = '{{TOKEN}}';
        // If server replaced it, serverToken will be the actual token (not the placeholder)
        // Check: if it exists, has length, and is not the literal placeholder string
        // (Note: server replaces ALL {{TOKEN}}, so we check if it's a real token by length/content)
        if (serverToken && typeof serverToken === 'string' && serverToken.length > 10) {
            // Looks like a real token (tokens are typically longer than 10 chars)
            token = serverToken;
        }
        
        // If server token wasn't available, extract from URL
        // Always try manual extraction first for tokens with special characters
        if (!token) {
            const search = window.location.search || window.location.href.split('?')[1] || '';
            // Match token=value, capturing everything after = until & or end of string
            // This handles tokens with = characters correctly
            const match = search.match(/[?&]token=([^&]*)/);
            if (match && match[1]) {
                try {
                    token = decodeURIComponent(match[1]);
                } catch (e) {
                    // If decode fails, use raw value
                    token = match[1];
                }
            }
        }
        
        // Fallback: Try URLSearchParams if manual extraction didn't work
        if (!token) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const urlToken = urlParams.get('token');
                if (urlToken && urlToken.trim() !== '') {
                    token = urlToken;
                }
            } catch (e) {
                // URLSearchParams failed, token remains null
            }
        }

        // Validate token - be more lenient, only check for truly invalid cases
        // Note: Don't check against '{{TOKEN}}' because server replaces ALL instances
        // Instead, just check if token exists and is not empty
        if (!token || (typeof token === 'string' && token.trim() === '')) {
            document.body.innerHTML = `
                <div style="padding: 40px; color: white; background: rgba(0,0,0,0.9); text-align: center; font-family: Arial, sans-serif; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div style="max-width: 600px; padding: 40px; background: rgba(255, 255, 255, 0.1); border-radius: 10px;">
                        <h1 style="color: #ff4444; margin-bottom: 20px; font-size: 32px;">Error: Missing Token</h1>
                        <p style="margin: 15px 0; font-size: 16px; line-height: 1.6;">This OBS Browser Source requires a token to identify your account.</p>
                        <p style="margin: 15px 0; font-size: 16px;"><strong>To get your token:</strong></p>
                        <ol style="text-align: left; margin: 20px 0; padding-left: 20px;">
                            <li style="margin: 10px 0;">Go to your <a href="/dashboard" style="color: #9146ff;">MultiBot Dashboard</a></li>
                            <li style="margin: 10px 0;">Scroll to the "OBS Setup" section</li>
                            <li style="margin: 10px 0;">Click "Generate OBS Token" if you haven't already</li>
                            <li style="margin: 10px 0;">Copy the URL shown (it will look like: <code style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 3px;">/obs-source?token=YOUR_TOKEN</code>)</li>
                            <li style="margin: 10px 0;">Use that complete URL in your OBS Browser Source</li>
                        </ol>
                        <a href="/dashboard" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background: #9146ff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">Go to Dashboard</a>
                    </div>
                </div>
            `;
            throw new Error('Token required');
        }

        // WebSocket connection
        let ws = null;
        let audioElements = new Map(); // Store audio elements by command ID
        let isConnected = false;

        // Determine WebSocket URL
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;

        // Connect to WebSocket
        function connect() {
            updateStatus('connecting', 'Connecting...');
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[OBS] WebSocket connected');
                // Send token to authenticate
                ws.send(JSON.stringify({
                    type: 'obs_authenticate',
                    token: token
                }));
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'obs_authenticated') {
                        isConnected = true;
                        updateStatus('connected', 'Connected');
                        console.log('[OBS] Authenticated successfully');
                    } else if (data.type === 'obs_auth_failed') {
                        isConnected = false;
                        updateStatus('disconnected', 'Auth Failed');
                        console.error('[OBS] Authentication failed:', data.message);
                    } else if (data.type === 'command_trigger') {
                        handleCommandTrigger(data.command);
                    } else if (data.type === 'design_update') {
                        // Live update design elements
                        console.log('[OBS] Design update received');
                        console.log('[OBS] Design data type:', typeof data.designData);
                        console.log('[OBS] Design data:', data.designData);
                        // Pass the design data string to loadDesignElements
                        loadDesignElements(data.designData);
                    }
                } catch (error) {
                    console.error('[OBS] Error parsing message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('[OBS] WebSocket error:', error);
                updateStatus('disconnected', 'Connection Error');
            };

            ws.onclose = () => {
                isConnected = false;
                updateStatus('disconnected', 'Disconnected');
                console.log('[OBS] WebSocket closed, reconnecting in 3 seconds...');
                // Reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
        }

        // Update status indicator (only show on errors/disconnections)
        function updateStatus(status, text) {
            const statusEl = document.getElementById('status');
            statusEl.className = status;
            statusEl.textContent = text;
            
            // Hide status when connected, show only on errors/disconnections
            if (status === 'connected' || status === 'connecting') {
                statusEl.style.display = 'none';
            } else {
                statusEl.style.display = 'block';
            }
        }

        // Handle command trigger
        function handleCommandTrigger(commandData) {
            if (commandData.type === 'audio_command') {
                playAudioCommand(commandData);
            }
        }

        // Play audio command
        function playAudioCommand(commandData) {
            const { id, filePath, volume, command } = commandData;
            
            console.log(`[OBS] Playing audio command: ${command} (${filePath})`);

            // Check if audio element already exists
            let audio = audioElements.get(id);
            
            if (!audio) {
                // Create new audio element
                audio = new Audio(filePath);
                audio.preload = 'auto';
                audioElements.set(id, audio);
            }

            // Set volume (0-1 range)
            audio.volume = Math.max(0, Math.min(1, volume || 0.5));

            // Play audio
            audio.play().catch(error => {
                console.error(`[OBS] Error playing audio for command ${command}:`, error);
            });

            // Show visual feedback (if enabled)
            const showFeedback = '{{SHOW_FEEDBACK}}' === 'true';
            if (showFeedback) {
                showCommandFeedback(command);
            }
        }

        // Show visual feedback
        function showCommandFeedback(command) {
            const feedback = document.getElementById('command-feedback');
            if (!feedback) return; // Safety check
            
            feedback.textContent = command;
            feedback.classList.add('show');
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 2000);
        }

        // Preload audio files (optional - can be enabled if needed)
        async function preloadAudioFiles() {
            // This could fetch the list of commands and preload them
            // For now, we'll load them on-demand
        }

        // Decode HTML entities (for &quot; etc.)
        function decodeHtmlEntities(str) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = str;
            return textarea.value;
        }

        // Load and render design elements
        function loadDesignElements(designDataStr) {
            let designElements = [];
            
            try {
                // If designDataStr is provided (from WebSocket update), use it first
                // Otherwise, fall back to window variable (from initial page load)
                if (designDataStr && designDataStr !== '{{DESIGN_DATA}}' && designDataStr !== '[]' && designDataStr.trim() !== '') {
                    // Decode HTML entities if needed (handles &quot; etc.)
                    let decoded = designDataStr;
                    try {
                        decoded = decodeHtmlEntities(designDataStr);
                    } catch (e) {
                        // If decodeHtmlEntities fails, try parsing directly
                        decoded = designDataStr;
                    }
                    
                    // Parse JSON
                    if (typeof decoded === 'string') {
                        designElements = JSON.parse(decoded);
                    } else {
                        designElements = Array.isArray(decoded) ? decoded : [];
                    }
                    console.log('[OBS] Loaded design elements from WebSocket update:', designElements.length);
                } 
                // Fall back to window variable (from initial page load) if no WebSocket data
                else if (window.__OBS_DESIGN_DATA__) {
                    designElements = Array.isArray(window.__OBS_DESIGN_DATA__) 
                        ? window.__OBS_DESIGN_DATA__ 
                        : JSON.parse(window.__OBS_DESIGN_DATA__);
                    console.log('[OBS] Loaded design elements from window variable:', designElements.length);
                } else {
                    console.log('[OBS] No design data found');
                }
            } catch (error) {
                console.error('[OBS] Error parsing design data:', error);
                console.error('[OBS] Design data string:', designDataStr);
                console.error('[OBS] Window data:', window.__OBS_DESIGN_DATA__);
                console.error('[OBS] Error details:', error.message);
            }
            
            const container = document.getElementById('design-container');
            if (!container) return;
            
            // Clear existing elements
            container.innerHTML = '';
            
            if (designElements.length === 0) {
                return; // No design elements to render
            }
            
            // Render each design element
            designElements.forEach((elementData) => {
                // Handle both old percentage format and new 1080p format
                let x1080p, y1080p, width1080p, height1080p;
                const OBS_CANVAS_WIDTH = 1920;
                const OBS_CANVAS_HEIGHT = 1080;
                
                if (elementData.x > 100) {
                    // New format: 1080p coordinates (pixels)
                    x1080p = elementData.x;
                    y1080p = elementData.y;
                    width1080p = elementData.width;
                    height1080p = elementData.height;
                } else {
                    // Old format: percentages (convert to 1080p)
                    x1080p = (elementData.x / 100) * OBS_CANVAS_WIDTH;
                    y1080p = (elementData.y / 100) * OBS_CANVAS_HEIGHT;
                    width1080p = elementData.width;
                    height1080p = elementData.height;
                }
                
                // Use pixel positioning directly (no percentage conversion needed)
                // x1080p and y1080p are already in pixels for 1920x1080 canvas
                
                let element;
                
                if (elementData.type === 'text') {
                    element = document.createElement('div');
                    element.textContent = elementData.text || '';
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        padding: 10px 20px;
                        background: rgba(255, 255, 255, 0.2);
                        backdrop-filter: blur(10px);
                        border: 2px solid rgba(255, 255, 255, 0.3);
                        border-radius: 8px;
                        color: ${elementData.color || '#ffffff'};
                        font-size: ${elementData.fontSize || 24}px;
                        font-weight: bold;
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        text-align: center;
                        box-sizing: border-box;
                    `;
                } else if (elementData.type === 'image') {
                    element = document.createElement('img');
                    element.src = elementData.imagePath;
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        object-fit: contain;
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        box-sizing: border-box;
                    `;
                } else if (elementData.type === 'circle' || elementData.type === 'square') {
                    element = document.createElement('div');
                    const isCircle = elementData.type === 'circle';
                    const borderRadius = isCircle ? 'border-radius: 50%;' : '';
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        ${borderRadius}
                        background: ${elementData.color || 'rgba(255, 100, 100, 0.5)'};
                        border: 2px solid rgba(255, 255, 255, 0.5);
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        box-sizing: border-box;
                    `;
                }
                
                if (element) {
                    container.appendChild(element);
                }
            });
            
            console.log(`[OBS] Rendered ${designElements.length} design elements`);
        }

        // Initialize
        connect();
        
        // Load initial design elements
        // The server embeds design data in window.__OBS_DESIGN_DATA__
        loadDesignElements();
    </script>
</body>
</html>

