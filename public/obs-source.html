<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiBot OBS Browser Source</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 1920px;
            height: 1080px;
            position: relative;
        }

        /* Status indicator - hidden by default, only show on errors */
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        
        /* Only show status when disconnected or error */
        #status.disconnected,
        #status.error {
            display: block;
        }

        #status.connected {
            background: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        #status.disconnected {
            background: rgba(255, 0, 0, 0.3);
            color: #ff0000;
        }

        #status.connecting {
            background: rgba(255, 255, 0, 0.3);
            color: #ffff00;
        }

        /* Hidden audio elements container */
        #audio-container {
            display: none;
        }

        /* Visual feedback (optional - can be enabled) */
        .command-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 999;
        }

        .command-feedback.show {
            opacity: 1;
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>
    <!-- Status indicator -->
    <div id="status" class="connecting">Connecting...</div>

    <!-- Visual feedback container -->
    <div id="command-feedback" class="command-feedback"></div>

    <!-- Audio container (hidden) -->
    <div id="audio-container"></div>

    <!-- Design elements container -->
    <div id="design-container" style="position: absolute; top: 0; left: 0; width: 1920px; height: 1080px; pointer-events: none; z-index: 1; overflow: visible;"></div>

    <!-- GIF display container -->
    <div id="gif-container" style="position: absolute; top: 0; left: 0; width: 1920px; height: 1080px; pointer-events: none; z-index: 9999; overflow: visible;"></div>

    <script>
        // Get token from URL - handle both URLSearchParams and direct string extraction
        let token = null;
        
        // First, try to get token from server-replaced placeholder (most reliable)
        // Server replaces {{TOKEN}} with actual token value
        const serverToken = '{{TOKEN}}';
        // If server replaced it, serverToken will be the actual token (not the placeholder)
        // Check: if it exists, has length, and is not the literal placeholder string
        // (Note: server replaces ALL {{TOKEN}}, so we check if it's a real token by length/content)
        if (serverToken && typeof serverToken === 'string' && serverToken.length > 10) {
            // Looks like a real token (tokens are typically longer than 10 chars)
            token = serverToken;
        }
        
        // If server token wasn't available, extract from URL
        // Always try manual extraction first for tokens with special characters
        if (!token) {
            const search = window.location.search || window.location.href.split('?')[1] || '';
            // Match token=value, capturing everything after = until & or end of string
            // This handles tokens with = characters correctly
            const match = search.match(/[?&]token=([^&]*)/);
            if (match && match[1]) {
                try {
                    token = decodeURIComponent(match[1]);
                } catch (e) {
                    // If decode fails, use raw value
                    token = match[1];
                }
            }
        }
        
        // Fallback: Try URLSearchParams if manual extraction didn't work
        if (!token) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const urlToken = urlParams.get('token');
                if (urlToken && urlToken.trim() !== '') {
                    token = urlToken;
                }
            } catch (e) {
                // URLSearchParams failed, token remains null
            }
        }

        // Validate token - be more lenient, only check for truly invalid cases
        // Note: Don't check against '{{TOKEN}}' because server replaces ALL instances
        // Instead, just check if token exists and is not empty
        if (!token || (typeof token === 'string' && token.trim() === '')) {
            document.body.innerHTML = `
                <div style="padding: 40px; color: white; background: rgba(0,0,0,0.9); text-align: center; font-family: Arial, sans-serif; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div style="max-width: 600px; padding: 40px; background: rgba(255, 255, 255, 0.1); border-radius: 10px;">
                        <h1 style="color: #ff4444; margin-bottom: 20px; font-size: 32px;">Error: Missing Token</h1>
                        <p style="margin: 15px 0; font-size: 16px; line-height: 1.6;">This OBS Browser Source requires a token to identify your account.</p>
                        <p style="margin: 15px 0; font-size: 16px;"><strong>To get your token:</strong></p>
                        <ol style="text-align: left; margin: 20px 0; padding-left: 20px;">
                            <li style="margin: 10px 0;">Go to your <a href="/dashboard" style="color: #9146ff;">MultiBot Dashboard</a></li>
                            <li style="margin: 10px 0;">Scroll to the "OBS Setup" section</li>
                            <li style="margin: 10px 0;">Click "Generate OBS Token" if you haven't already</li>
                            <li style="margin: 10px 0;">Copy the URL shown (it will look like: <code style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 3px;">/obs-source?token=YOUR_TOKEN</code>)</li>
                            <li style="margin: 10px 0;">Use that complete URL in your OBS Browser Source</li>
                        </ol>
                        <a href="/dashboard" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background: #9146ff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">Go to Dashboard</a>
                    </div>
                </div>
            `;
            throw new Error('Token required');
        }

        // WebSocket connection
        let ws = null;
        let audioElements = new Map(); // Store audio elements by command ID
        let isConnected = false;

        // Determine WebSocket URL
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;

        // Connect to WebSocket
        function connect() {
            updateStatus('connecting', 'Connecting...');
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[OBS] WebSocket connected');
                // Send token to authenticate
                ws.send(JSON.stringify({
                    type: 'obs_authenticate',
                    token: token
                }));
            };

            ws.onmessage = (event) => {
                console.log('[OBS] WebSocket message received:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    console.log('[OBS] Parsed message data:', data);
                    console.log('[OBS] Message type:', data.type);
                    
                    if (data.type === 'obs_authenticated') {
                        isConnected = true;
                        updateStatus('connected', 'Connected');
                        console.log('[OBS] Authenticated successfully');
                    } else if (data.type === 'obs_auth_failed') {
                        isConnected = false;
                        updateStatus('disconnected', 'Auth Failed');
                        console.error('[OBS] Authentication failed:', data.message);
                    } else if (data.type === 'command_trigger') {
                        console.log('[OBS] Command trigger received - full data:', data);
                        console.log('[OBS] Command data:', data.command);
                        handleCommandTrigger(data.command);
                    } else if (data.type === 'design_update') {
                        // Live update design elements
                        console.log('[OBS] Design update received');
                        console.log('[OBS] Design data type:', typeof data.designData);
                        console.log('[OBS] Design data:', data.designData);
                        // Pass the design data string to loadDesignElements
                        loadDesignElements(data.designData);
                    } else if (data.type === 'chat_message') {
                        // Chat messages are for dashboard, ignore in OBS source
                        console.log('[OBS] Chat message received (ignored in OBS source)');
                    } else {
                        console.warn('[OBS] Unknown message type:', data.type);
                    }
                } catch (error) {
                    console.error('[OBS] Error parsing message:', error);
                    console.error('[OBS] Raw message:', event.data);
                }
            };

            ws.onerror = (error) => {
                console.error('[OBS] WebSocket error:', error);
                updateStatus('disconnected', 'Connection Error');
            };

            ws.onclose = () => {
                isConnected = false;
                updateStatus('disconnected', 'Disconnected');
                console.log('[OBS] WebSocket closed, reconnecting in 3 seconds...');
                // Reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
        }

        // Update status indicator (only show on errors/disconnections)
        function updateStatus(status, text) {
            const statusEl = document.getElementById('status');
            statusEl.className = status;
            statusEl.textContent = text;
            
            // Hide status when connected, show only on errors/disconnections
            if (status === 'connected' || status === 'connecting') {
                statusEl.style.display = 'none';
            } else {
                statusEl.style.display = 'block';
            }
        }

        // Handle command trigger
        function handleCommandTrigger(commandData) {
            console.log('[OBS] ========================================');
            console.log('[OBS] handleCommandTrigger called with:', commandData);
            console.log('[OBS] Command type:', commandData?.type);
            console.log('[OBS] Full command data:', JSON.stringify(commandData, null, 2));
            
            if (!commandData || !commandData.type) {
                console.error('[OBS] Invalid command data - missing type:', commandData);
                return;
            }
            
            if (commandData.type === 'audio_command') {
                console.log('[OBS] Processing audio command');
                playAudioCommand(commandData);
            } else if (commandData.type === 'gif_command') {
                console.log('[OBS] Processing GIF command');
                showGifCommand(commandData);
            } else {
                console.warn('[OBS] Unknown command type:', commandData?.type);
            }
            console.log('[OBS] ========================================');
        }

        // Play audio command
        function playAudioCommand(commandData) {
            const { id, filePath, volume, command } = commandData;
            
            console.log(`[OBS] Playing audio command: ${command} (${filePath})`);

            // Check if audio element already exists
            let audio = audioElements.get(id);
            
            if (!audio) {
                // Create new audio element
                audio = new Audio(filePath);
                audio.preload = 'auto';
                audioElements.set(id, audio);
            }

            // Set volume (0-1 range)
            audio.volume = Math.max(0, Math.min(1, volume || 0.5));

            // Play audio
            audio.play().catch(error => {
                console.error(`[OBS] Error playing audio for command ${command}:`, error);
            });

            // Show visual feedback (if enabled)
            const showFeedback = '{{SHOW_FEEDBACK}}' === 'true';
            if (showFeedback) {
                showCommandFeedback(command);
            }
        }

        // Show visual feedback
        function showCommandFeedback(command) {
            const feedback = document.getElementById('command-feedback');
            if (!feedback) return; // Safety check
            
            feedback.textContent = command;
            feedback.classList.add('show');
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 2000);
        }

        // Show GIF command
        function showGifCommand(commandData) {
            console.log('[OBS] showGifCommand called with:', JSON.stringify(commandData, null, 2));
            console.log('[OBS] Position from commandData:', commandData.position, 'Type:', typeof commandData.position);
            console.log('[OBS] Size from commandData:', commandData.size, 'Type:', typeof commandData.size);
            
            // Extract values with proper fallbacks for null/undefined/empty string
            const gifUrl = commandData.gifUrl;
            const duration = commandData.duration || 5000;
            
            // Handle position - check for string methods safely
            let position = 'center';
            if (commandData.position) {
                if (typeof commandData.position === 'string' && commandData.position.trim() !== '') {
                    position = commandData.position.trim();
                } else if (commandData.position !== null && commandData.position !== undefined) {
                    position = String(commandData.position).trim();
                }
            }
            
            // Handle size - check for string methods safely
            let size = 'medium';
            if (commandData.size) {
                if (typeof commandData.size === 'string' && commandData.size.trim() !== '') {
                    size = commandData.size.trim();
                } else if (commandData.size !== null && commandData.size !== undefined) {
                    size = String(commandData.size).trim();
                }
            }
            
            console.log('[OBS] Extracted values - position:', position, 'size:', size);
            console.log('[OBS] Position styles will be:', getPositionStyles(position));
            console.log('[OBS] Size styles will be:', getSizeStyles(size));
            
            if (!gifUrl) {
                console.error('[OBS] No gifUrl provided in commandData:', commandData);
                return;
            }
            
            console.log(`[OBS] Showing GIF: ${gifUrl} for ${duration}ms at position: ${position}, size: ${size}`);

            const gifContainer = document.getElementById('gif-container');
            if (!gifContainer) {
                console.error('[OBS] GIF container not found!');
                return;
            }
            
            console.log('[OBS] GIF container found:', gifContainer);

            // Clear any existing GIFs first
            gifContainer.innerHTML = '';
            console.log('[OBS] Cleared existing GIFs');

            // Calculate position styles based on position option
            const positionStyles = getPositionStyles(position);
            console.log('[OBS] Position value:', position, '-> Position styles:', positionStyles);
            
            // Calculate size styles based on size option
            const sizeStyles = getSizeStyles(size);
            console.log('[OBS] Size value:', size, '-> Size styles:', sizeStyles);
            
            // Create GIF element with position and size
            const gifElement = document.createElement('img');
            gifElement.src = gifUrl;
            
            const finalStyles = `
                position: absolute;
                ${positionStyles}
                ${sizeStyles}
                object-fit: contain;
                pointer-events: none;
                z-index: 9999;
            `;
            
            console.log('[OBS] Final CSS styles:', finalStyles);
            gifElement.style.cssText = finalStyles;
            
            console.log('[OBS] Created GIF element with src:', gifUrl);
            
            // Verify styles are applied after load
            gifElement.onload = () => {
                const computed = window.getComputedStyle(gifElement);
                console.log('[OBS] GIF loaded - Computed styles:', {
                    position: computed.position,
                    top: computed.top,
                    left: computed.left,
                    right: computed.right,
                    bottom: computed.bottom,
                    maxWidth: computed.maxWidth,
                    maxHeight: computed.maxHeight,
                    width: computed.width,
                    height: computed.height
                });
            };

            // Add load and error handlers for debugging
            gifElement.onload = () => {
                console.log('[OBS] GIF loaded successfully');
            };
            
            gifElement.onerror = (error) => {
                console.error('[OBS] Error loading GIF:', error);
                console.error('[OBS] GIF URL:', gifUrl);
            };

            gifContainer.appendChild(gifElement);
            console.log('[OBS] ✓ GIF element appended to container');
            console.log('[OBS] Container children count:', gifContainer.children.length);
            console.log('[OBS] GIF element HTML:', gifElement.outerHTML.substring(0, 200));
            
            // Verify it's actually in the DOM
            const verifyElement = document.getElementById('gif-container');
            if (verifyElement && verifyElement.contains(gifElement)) {
                console.log('[OBS] ✓ Verified: GIF element is in the DOM');
            } else {
                console.error('[OBS] ✗ ERROR: GIF element NOT found in DOM after append!');
            }

            // Remove GIF after duration
            setTimeout(() => {
                console.log('[OBS] Removing GIF after duration');
                if (gifElement.parentNode) {
                    gifElement.parentNode.removeChild(gifElement);
                    console.log('[OBS] GIF removed');
                }
            }, duration);
        }

        // Get CSS styles for position
        function getPositionStyles(position) {
            const positions = {
                'top-left': 'top: 10px; left: 10px; transform: translate(0, 0);',
                'top-center': 'top: 10px; left: 50%; transform: translate(-50%, 0);',
                'top-right': 'top: 10px; right: 10px; transform: translate(0, 0);',
                'center-left': 'top: 50%; left: 10px; transform: translate(0, -50%);',
                'center': 'top: 50%; left: 50%; transform: translate(-50%, -50%);',
                'center-right': 'top: 50%; right: 10px; transform: translate(0, -50%);',
                'bottom-left': 'bottom: 10px; left: 10px; transform: translate(0, 0);',
                'bottom-center': 'bottom: 10px; left: 50%; transform: translate(-50%, 0);',
                'bottom-right': 'bottom: 10px; right: 10px; transform: translate(0, 0);'
            };
            return positions[position] || positions['center'];
        }

        // Get CSS styles for size (preserves aspect ratio)
        function getSizeStyles(size) {
            const sizes = {
                'small': 'max-width: 128px; max-height: 128px; width: auto; height: auto;',
                'medium': 'max-width: 512px; max-height: 512px; width: auto; height: auto;',
                'original': 'max-width: 90%; max-height: 90%; width: auto; height: auto;'
            };
            return sizes[size] || sizes['medium'];
        }

        // Preload audio files (optional - can be enabled if needed)
        async function preloadAudioFiles() {
            // This could fetch the list of commands and preload them
            // For now, we'll load them on-demand
        }

        // Decode HTML entities (for &quot; etc.)
        function decodeHtmlEntities(str) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = str;
            return textarea.value;
        }

        // Load and render design elements
        function loadDesignElements(designDataStr) {
            let designElements = [];
            
            try {
                // If designDataStr is provided (from WebSocket update), use it first
                // Otherwise, fall back to window variable (from initial page load)
                if (designDataStr && designDataStr !== '{{DESIGN_DATA}}' && designDataStr !== '[]' && designDataStr.trim() !== '') {
                    // Decode HTML entities if needed (handles &quot; etc.)
                    let decoded = designDataStr;
                    try {
                        decoded = decodeHtmlEntities(designDataStr);
                    } catch (e) {
                        // If decodeHtmlEntities fails, try parsing directly
                        decoded = designDataStr;
                    }
                    
                    // Parse JSON
                    if (typeof decoded === 'string') {
                        designElements = JSON.parse(decoded);
                    } else {
                        designElements = Array.isArray(decoded) ? decoded : [];
                    }
                    console.log('[OBS] Loaded design elements from WebSocket update:', designElements.length);
                } 
                // Fall back to window variable (from initial page load) if no WebSocket data
                else if (window.__OBS_DESIGN_DATA__) {
                    designElements = Array.isArray(window.__OBS_DESIGN_DATA__) 
                        ? window.__OBS_DESIGN_DATA__ 
                        : JSON.parse(window.__OBS_DESIGN_DATA__);
                    console.log('[OBS] Loaded design elements from window variable:', designElements.length);
                } else {
                    console.log('[OBS] No design data found');
                }
            } catch (error) {
                console.error('[OBS] Error parsing design data:', error);
                console.error('[OBS] Design data string:', designDataStr);
                console.error('[OBS] Window data:', window.__OBS_DESIGN_DATA__);
                console.error('[OBS] Error details:', error.message);
            }
            
            const container = document.getElementById('design-container');
            if (!container) return;
            
            // Clear existing elements
            container.innerHTML = '';
            
            if (designElements.length === 0) {
                return; // No design elements to render
            }
            
            // Render each design element
            designElements.forEach((elementData) => {
                // Handle both old percentage format and new 1080p format
                let x1080p, y1080p, width1080p, height1080p;
                const OBS_CANVAS_WIDTH = 1920;
                const OBS_CANVAS_HEIGHT = 1080;
                
                if (elementData.x > 100) {
                    // New format: 1080p coordinates (pixels)
                    x1080p = elementData.x;
                    y1080p = elementData.y;
                    width1080p = elementData.width;
                    height1080p = elementData.height;
                } else {
                    // Old format: percentages (convert to 1080p)
                    x1080p = (elementData.x / 100) * OBS_CANVAS_WIDTH;
                    y1080p = (elementData.y / 100) * OBS_CANVAS_HEIGHT;
                    width1080p = elementData.width;
                    height1080p = elementData.height;
                }
                
                // Use pixel positioning directly (no percentage conversion needed)
                // x1080p and y1080p are already in pixels for 1920x1080 canvas
                
                let element;
                
                if (elementData.type === 'text') {
                    element = document.createElement('div');
                    element.textContent = elementData.text || '';
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        padding: 10px 20px;
                        background: rgba(255, 255, 255, 0.2);
                        backdrop-filter: blur(10px);
                        border: 2px solid rgba(255, 255, 255, 0.3);
                        border-radius: 8px;
                        color: ${elementData.color || '#ffffff'};
                        font-size: ${elementData.fontSize || 24}px;
                        font-weight: bold;
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        text-align: center;
                        box-sizing: border-box;
                    `;
                } else if (elementData.type === 'image') {
                    element = document.createElement('img');
                    element.src = elementData.imagePath;
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        object-fit: contain;
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        box-sizing: border-box;
                    `;
                } else if (elementData.type === 'circle' || elementData.type === 'square') {
                    element = document.createElement('div');
                    const isCircle = elementData.type === 'circle';
                    const borderRadius = isCircle ? 'border-radius: 50%;' : '';
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        ${borderRadius}
                        background: ${elementData.color || 'rgba(255, 100, 100, 0.5)'};
                        border: 2px solid rgba(255, 255, 255, 0.5);
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        box-sizing: border-box;
                    `;
                }
                
                if (element) {
                    container.appendChild(element);
                }
            });
            
            console.log(`[OBS] Rendered ${designElements.length} design elements`);
        }

        // Initialize
        connect();
        
        // Load initial design elements
        // The server embeds design data in window.__OBS_DESIGN_DATA__
        loadDesignElements();
    </script>
</body>
</html>

