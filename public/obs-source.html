<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiBot OBS Browser Source</title>
    <!-- Preload fonts used by animated text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nabla:EDPT,EHLT@30..200,24&family=Varela+Round&family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Oswald:wght@400;700&family=Bebas+Neue&family=Orbitron:wght@400;700&family=Press+Start+2P&family=Pacifico&display=swap">
    <!-- animate.css (local vendored copy) -->
    <link rel="stylesheet" href="/vendor/animate/animate.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 1920px;
            height: 1080px;
            position: relative;
        }

        /* Status indicator - hidden by default, only show on errors */
        #status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        
        /* Only show status when disconnected or error */
        #status.disconnected,
        #status.error {
            display: block;
        }

        #status.connected {
            background: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        #status.disconnected {
            background: rgba(255, 0, 0, 0.3);
            color: #ff0000;
        }

        #status.connecting {
            background: rgba(255, 255, 0, 0.3);
            color: #ffff00;
        }

        /* Hidden audio elements container */
        #audio-container {
            display: none;
        }

        /* Visual feedback (optional - can be enabled) */
        .command-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 999;
        }

        .command-feedback.show {
            opacity: 1;
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Nabla (COLRv1) palette settings (only works on newer Chromium/CEF) */
        @font-palette-values --Nabla {
            font-family: Nabla;
            base-palette: 2;
        }
        .nabla-font {
            font-family: Nabla, sans-serif;
            font-palette: --Nabla;
        }

        /* 3D animated text: per-letter spans (ONLY for Nabla variable font) */
        @keyframes depth {
            0% {
                transform: translateX(0) translateY(0);
                font-variation-settings: "EDPT" 30;
            }
            100% {
                font-variation-settings: "EDPT" 200;
                transform: translateX(0.15em) translateY(0.1em);
            }
        }
        .animated-text-3d span {
            display: inline-block;
            position: relative;
            animation: depth 1s ease-in-out alternate infinite;
            font-variation-settings: "EDPT" 30;
        }
        
        /* 3D text for non-Nabla fonts: whole text with stacked shadows */
        @keyframes text3d-pulse {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }
        .animated-text-3d-solid {
            animation: text3d-pulse 2s ease-in-out infinite;
        }

        /* Text Block (wipe) animation - no hover, loops automatically */
        .text-block {
            position: relative;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            padding: 0 0 10px 0;
            border: 2px solid var(--tb-accent, #ff1ead);
            border-radius: 6px;
            background: transparent;
            overflow: hidden;
        }
        .text-block::before,
        .text-block::after {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 0%;
            z-index: -1;
        }
        .text-block::before {
            background: var(--tb-accent, #ff1ead);
            animation: tbFill1 var(--tb-cycle, 2400ms) ease-in-out infinite;
        }
        .text-block::after {
            background: var(--tb-secondary, #ffffff);
            z-index: -2;
            animation: tbFill2 var(--tb-cycle, 2400ms) ease-in-out infinite;
        }
        .text-block h1 {
            margin: 0;
            padding: 0 16px;
            line-height: 1;
            font-weight: 700;
            /* stroke + gradient text fill like your demo */
            -webkit-text-stroke: 2px white;
            background-image: linear-gradient(transparent 50%, white 50%);
            background-size: 100% 200%;
            background-position: top;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: tbText var(--tb-cycle, 2400ms) ease-in-out infinite;
            white-space: nowrap;
        }

        @keyframes tbFill1 {
            /* layer 1: starts later (like hover delay) */
            0%   { height: 0%; }
            20%  { height: 0%; }
            45%  { height: 100%; }
            70%  { height: 100%; }
            90%  { height: 0%; }
            100% { height: 0%; }
        }
        @keyframes tbFill2 {
            /* layer 2: slightly earlier than layer 1 */
            0%   { height: 0%; }
            15%  { height: 0%; }
            40%  { height: 100%; }
            70%  { height: 100%; }
            88%  { height: 0%; }
            100% { height: 0%; }
        }
        @keyframes tbText {
            0%   { background-position: top; }
            35%  { background-position: top; }
            60%  { background-position: bottom; }
            100% { background-position: top; }
        }
    </style>
</head>
<body>
    <!-- Status indicator -->
    <div id="status" class="connecting">Connecting...</div>

    <!-- Visual feedback container -->
    <div id="command-feedback" class="command-feedback"></div>

    <!-- Audio container (hidden) -->
    <div id="audio-container"></div>

    <!-- Design elements container -->
    <div id="design-container" style="position: absolute; top: 0; left: 0; width: 1920px; height: 1080px; pointer-events: none; z-index: 1; overflow: visible;"></div>

    <!-- GIF display container -->
    <div id="gif-container" style="position: absolute; top: 0; left: 0; width: 1920px; height: 1080px; pointer-events: none; z-index: 9999; overflow: visible;"></div>

    <!-- Animated text display container -->
    <div id="animated-text-container" style="position: absolute; top: 0; left: 0; width: 1920px; height: 1080px; pointer-events: none; z-index: 10000; overflow: visible;"></div>

    <script>
        // Animated text transitions (fade / slide / pop)
        // Implemented as a 2-step process (apply initial styles BEFORE append, then play-in AFTER append)
        function buildAnimatedTextTransition(commandData) {
            const preset = (commandData && commandData.transitionPreset) ? String(commandData.transitionPreset) : 'fade';
            const inMsRaw = commandData?.transitionInMs;
            const outMsRaw = commandData?.transitionOutMs;
            const distRaw = commandData?.transitionDistance;

            const safeInMs = Number.isFinite(inMsRaw) ? Math.max(0, Math.min(inMsRaw, 5000)) : Math.max(0, Math.min(parseInt(inMsRaw || 250, 10) || 250, 5000));
            const safeOutMs = Number.isFinite(outMsRaw) ? Math.max(0, Math.min(outMsRaw, 5000)) : Math.max(0, Math.min(parseInt(outMsRaw || 400, 10) || 400, 5000));
            const safeDistance = Number.isFinite(distRaw) ? Math.max(0, Math.min(distRaw, 500)) : Math.max(0, Math.min(parseInt(distRaw || 40, 10) || 40, 500));

            // Base transform keeps the element centered at (x,y)
            const base = 'translate(-50%, -50%)';

            // Determine enter/exit deltas
            let enterDx = 0, enterDy = 0, enterScale = 1;
            let exitDx = 0, exitDy = 0, exitScale = 1;
            let fade = false;

            switch (preset) {
                case 'fade':
                    fade = true;
                    exitScale = 1.03;
                    break;
                case 'fade-slide-up':
                    fade = true;
                    enterDy = safeDistance;
                    exitDy = -safeDistance;
                    break;
                case 'fade-slide-down':
                    fade = true;
                    enterDy = -safeDistance;
                    exitDy = safeDistance;
                    break;
                case 'fade-slide-left':
                    fade = true;
                    enterDx = safeDistance;
                    exitDx = -safeDistance;
                    break;
                case 'fade-slide-right':
                    fade = true;
                    enterDx = -safeDistance;
                    exitDx = safeDistance;
                    break;
                case 'pop':
                    fade = true;
                    enterScale = 0.96;
                    exitScale = 1.06;
                    break;
                case 'slide-up':
                    enterDy = safeDistance;
                    exitDy = -safeDistance;
                    break;
                case 'slide-down':
                    enterDy = -safeDistance;
                    exitDy = safeDistance;
                    break;
                case 'slide-left':
                    enterDx = safeDistance;
                    exitDx = -safeDistance;
                    break;
                case 'slide-right':
                    enterDx = -safeDistance;
                    exitDx = safeDistance;
                    break;
                default:
                    fade = true;
                    break;
            }

            const applyInitial = (el) => {
                el.style.willChange = 'transform, opacity';
                el.style.transition = `opacity ${safeInMs}ms ease, transform ${safeInMs}ms ease`;
                if (fade) el.style.opacity = '0';
                el.style.transform = `${base} translate(${enterDx}px, ${enterDy}px) scale(${enterScale})`;
            };

            const playIn = (el) => {
                requestAnimationFrame(() => {
                    // In OBS/CEF, a single rAF is often enough when initial styles were applied pre-append
                    if (fade) el.style.opacity = '1';
                    el.style.transform = `${base} translate(0px, 0px) scale(1)`;
                });
            };

            const startExit = (el) => {
                el.style.transition = `opacity ${safeOutMs}ms ease, transform ${safeOutMs}ms ease`;
                if (fade) el.style.opacity = '0';
                el.style.transform = `${base} translate(${exitDx}px, ${exitDy}px) scale(${exitScale})`;
                return safeOutMs;
            };

            return { preset, applyInitial, playIn, startExit, inMs: safeInMs, outMs: safeOutMs };
        }

        // Get token from URL - handle both URLSearchParams and direct string extraction
        let token = null;
        
        // First, try to get token from server-replaced placeholder (most reliable)
        // Server replaces {{TOKEN}} with actual token value
        const serverToken = '{{TOKEN}}';
        // If server replaced it, serverToken will be the actual token (not the placeholder)
        // Check: if it exists, has length, and is not the literal placeholder string
        // (Note: server replaces ALL {{TOKEN}}, so we check if it's a real token by length/content)
        if (serverToken && typeof serverToken === 'string' && serverToken.length > 10) {
            // Looks like a real token (tokens are typically longer than 10 chars)
            token = serverToken;
        }
        
        // If server token wasn't available, extract from URL
        // Always try manual extraction first for tokens with special characters
        if (!token) {
            const search = window.location.search || window.location.href.split('?')[1] || '';
            // Match token=value, capturing everything after = until & or end of string
            // This handles tokens with = characters correctly
            const match = search.match(/[?&]token=([^&]*)/);
            if (match && match[1]) {
                try {
                    token = decodeURIComponent(match[1]);
                } catch (e) {
                    // If decode fails, use raw value
                    token = match[1];
                }
            }
        }
        
        // Fallback: Try URLSearchParams if manual extraction didn't work
        if (!token) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const urlToken = urlParams.get('token');
                if (urlToken && urlToken.trim() !== '') {
                    token = urlToken;
                }
            } catch (e) {
                // URLSearchParams failed, token remains null
            }
        }

        // Validate token - be more lenient, only check for truly invalid cases
        // Note: Don't check against '{{TOKEN}}' because server replaces ALL instances
        // Instead, just check if token exists and is not empty
        if (!token || (typeof token === 'string' && token.trim() === '')) {
            document.body.innerHTML = `
                <div style="padding: 40px; color: white; background: rgba(0,0,0,0.9); text-align: center; font-family: Arial, sans-serif; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div style="max-width: 600px; padding: 40px; background: rgba(255, 255, 255, 0.1); border-radius: 10px;">
                        <h1 style="color: #ff4444; margin-bottom: 20px; font-size: 32px;">Error: Missing Token</h1>
                        <p style="margin: 15px 0; font-size: 16px; line-height: 1.6;">This OBS Browser Source requires a token to identify your account.</p>
                        <p style="margin: 15px 0; font-size: 16px;"><strong>To get your token:</strong></p>
                        <ol style="text-align: left; margin: 20px 0; padding-left: 20px;">
                            <li style="margin: 10px 0;">Go to your <a href="/dashboard" style="color: #9146ff;">MultiBot Dashboard</a></li>
                            <li style="margin: 10px 0;">Scroll to the "OBS Setup" section</li>
                            <li style="margin: 10px 0;">Click "Generate OBS Token" if you haven't already</li>
                            <li style="margin: 10px 0;">Copy the URL shown (it will look like: <code style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 3px;">/obs-source?token=YOUR_TOKEN</code>)</li>
                            <li style="margin: 10px 0;">Use that complete URL in your OBS Browser Source</li>
                        </ol>
                        <a href="/dashboard" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background: #9146ff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">Go to Dashboard</a>
                    </div>
                </div>
            `;
            throw new Error('Token required');
        }

        // WebSocket connection
        let ws = null;
        let audioElements = new Map(); // Store audio elements by command ID
        let isConnected = false;

        // Determine WebSocket URL
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;

        // Connect to WebSocket
        function connect() {
            updateStatus('connecting', 'Connecting...');
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('[OBS] WebSocket connected');
                // Send token to authenticate
                ws.send(JSON.stringify({
                    type: 'obs_authenticate',
                    token: token
                }));
            };

            ws.onmessage = (event) => {
                console.log('[OBS] WebSocket message received:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    console.log('[OBS] Parsed message data:', data);
                    console.log('[OBS] Message type:', data.type);
                    
                    if (data.type === 'obs_authenticated') {
                        isConnected = true;
                        updateStatus('connected', 'Connected');
                        console.log('[OBS] Authenticated successfully');
                    } else if (data.type === 'obs_auth_failed') {
                        isConnected = false;
                        updateStatus('disconnected', 'Auth Failed');
                        console.error('[OBS] Authentication failed:', data.message);
                    } else if (data.type === 'command_trigger') {
                        console.log('[OBS] Command trigger received - full data:', data);
                        console.log('[OBS] Command data:', data.command);
                        handleCommandTrigger(data.command);
                    } else if (data.type === 'design_update') {
                        // Live update design elements
                        console.log('[OBS] Design update received');
                        console.log('[OBS] Design data type:', typeof data.designData);
                        console.log('[OBS] Design data:', data.designData);
                        // Pass the design data string to loadDesignElements
                        loadDesignElements(data.designData);
                    } else if (data.type === 'chat_message') {
                        // Chat messages are for dashboard, ignore in OBS source
                        console.log('[OBS] Chat message received (ignored in OBS source)');
                    } else {
                        console.warn('[OBS] Unknown message type:', data.type);
                    }
                } catch (error) {
                    console.error('[OBS] Error parsing message:', error);
                    console.error('[OBS] Raw message:', event.data);
                }
            };

            ws.onerror = (error) => {
                console.error('[OBS] WebSocket error:', error);
                updateStatus('disconnected', 'Connection Error');
            };

            ws.onclose = () => {
                isConnected = false;
                updateStatus('disconnected', 'Disconnected');
                console.log('[OBS] WebSocket closed, reconnecting in 3 seconds...');
                // Reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
        }

        // Update status indicator (only show on errors/disconnections)
        function updateStatus(status, text) {
            const statusEl = document.getElementById('status');
            statusEl.className = status;
            statusEl.textContent = text;
            
            // Hide status when connected, show only on errors/disconnections
            if (status === 'connected' || status === 'connecting') {
                statusEl.style.display = 'none';
            } else {
                statusEl.style.display = 'block';
            }
        }

        // Handle command trigger
        function handleCommandTrigger(commandData) {
            console.log('[OBS] ========================================');
            console.log('[OBS] handleCommandTrigger called with:', commandData);
            console.log('[OBS] Command type:', commandData?.type);
            console.log('[OBS] Full command data:', JSON.stringify(commandData, null, 2));
            
            if (!commandData || !commandData.type) {
                console.error('[OBS] Invalid command data - missing type:', commandData);
                return;
            }
            
            if (commandData.type === 'audio_command') {
                console.log('[OBS] Processing audio command');
                playAudioCommand(commandData);
            } else if (commandData.type === 'gif_command') {
                console.log('[OBS] Processing GIF command');
                showGifCommand(commandData);
            } else if (commandData.type === 'animated_text_command') {
                console.log('[OBS] Processing animated text command');
                showAnimatedTextCommand(commandData);
            } else {
                console.warn('[OBS] Unknown command type:', commandData?.type);
            }
            console.log('[OBS] ========================================');
        }

        // Play audio command
        function playAudioCommand(commandData) {
            const { id, filePath, volume, command } = commandData;
            
            console.log(`[OBS] Playing audio command: ${command} (${filePath})`);

            // Check if audio element already exists
            let audio = audioElements.get(id);
            
            if (!audio) {
                // Create new audio element
                audio = new Audio(filePath);
                audio.preload = 'auto';
                audioElements.set(id, audio);
            }

            // Set volume (0-1 range)
            audio.volume = Math.max(0, Math.min(1, volume || 0.5));

            // Play audio
            audio.play().catch(error => {
                console.error(`[OBS] Error playing audio for command ${command}:`, error);
            });

            // Show visual feedback (if enabled)
            const showFeedback = '{{SHOW_FEEDBACK}}' === 'true';
            if (showFeedback) {
                showCommandFeedback(command);
            }
        }

        // Show visual feedback
        function showCommandFeedback(command) {
            const feedback = document.getElementById('command-feedback');
            if (!feedback) return; // Safety check
            
            feedback.textContent = command;
            feedback.classList.add('show');
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, 2000);
        }

        // Show GIF command
        function showGifCommand(commandData) {
            console.log('[OBS] showGifCommand called with:', JSON.stringify(commandData, null, 2));
            console.log('[OBS] Position from commandData:', commandData.position, 'Type:', typeof commandData.position);
            console.log('[OBS] Size from commandData:', commandData.size, 'Type:', typeof commandData.size);
            
            // Extract values with proper fallbacks for null/undefined/empty string
            const gifUrl = commandData.gifUrl;
            const duration = commandData.duration || 5000;
            
            // Handle position - check for string methods safely
            let position = 'center';
            if (commandData.position) {
                if (typeof commandData.position === 'string' && commandData.position.trim() !== '') {
                    position = commandData.position.trim();
                } else if (commandData.position !== null && commandData.position !== undefined) {
                    position = String(commandData.position).trim();
                }
            }
            
            // Handle size - check for string methods safely
            let size = 'medium';
            if (commandData.size) {
                if (typeof commandData.size === 'string' && commandData.size.trim() !== '') {
                    size = commandData.size.trim();
                } else if (commandData.size !== null && commandData.size !== undefined) {
                    size = String(commandData.size).trim();
                }
            }
            
            console.log('[OBS] Extracted values - position:', position, 'size:', size);
            console.log('[OBS] Position styles will be:', getPositionStyles(position));
            console.log('[OBS] Size styles will be:', getSizeStyles(size));
            
            if (!gifUrl) {
                console.error('[OBS] No gifUrl provided in commandData:', commandData);
                return;
            }
            
            console.log(`[OBS] Showing GIF: ${gifUrl} for ${duration}ms at position: ${position}, size: ${size}`);

            const gifContainer = document.getElementById('gif-container');
            if (!gifContainer) {
                console.error('[OBS] GIF container not found!');
                return;
            }
            
            console.log('[OBS] GIF container found:', gifContainer);

            // Clear any existing GIFs first
            gifContainer.innerHTML = '';
            console.log('[OBS] Cleared existing GIFs');

            // Calculate position styles based on position option
            const positionStyles = getPositionStyles(position);
            console.log('[OBS] Position value:', position, '-> Position styles:', positionStyles);
            
            // Calculate size styles based on size option
            const sizeStyles = getSizeStyles(size);
            console.log('[OBS] Size value:', size, '-> Size styles:', sizeStyles);
            
            // Create GIF element with position and size
            const gifElement = document.createElement('img');
            gifElement.src = gifUrl;
            
            const finalStyles = `
                position: absolute;
                ${positionStyles}
                ${sizeStyles}
                object-fit: contain;
                pointer-events: none;
                z-index: 9999;
            `;
            
            console.log('[OBS] Final CSS styles:', finalStyles);
            gifElement.style.cssText = finalStyles;
            
            console.log('[OBS] Created GIF element with src:', gifUrl);
            
            // Verify styles are applied after load
            gifElement.onload = () => {
                const computed = window.getComputedStyle(gifElement);
                console.log('[OBS] GIF loaded - Computed styles:', {
                    position: computed.position,
                    top: computed.top,
                    left: computed.left,
                    right: computed.right,
                    bottom: computed.bottom,
                    maxWidth: computed.maxWidth,
                    maxHeight: computed.maxHeight,
                    width: computed.width,
                    height: computed.height
                });
            };

            // Add load and error handlers for debugging
            gifElement.onload = () => {
                console.log('[OBS] GIF loaded successfully');
            };
            
            gifElement.onerror = (error) => {
                console.error('[OBS] Error loading GIF:', error);
                console.error('[OBS] GIF URL:', gifUrl);
            };

            gifContainer.appendChild(gifElement);
            console.log('[OBS] ✓ GIF element appended to container');
            console.log('[OBS] Container children count:', gifContainer.children.length);
            console.log('[OBS] GIF element HTML:', gifElement.outerHTML.substring(0, 200));
            
            // Verify it's actually in the DOM
            const verifyElement = document.getElementById('gif-container');
            if (verifyElement && verifyElement.contains(gifElement)) {
                console.log('[OBS] ✓ Verified: GIF element is in the DOM');
            } else {
                console.error('[OBS] ✗ ERROR: GIF element NOT found in DOM after append!');
            }

            // Remove GIF after duration
            setTimeout(() => {
                console.log('[OBS] Removing GIF after duration');
                if (gifElement.parentNode) {
                    gifElement.parentNode.removeChild(gifElement);
                    console.log('[OBS] GIF removed');
                }
            }, duration);
        }

        // Get CSS styles for position
        function getPositionStyles(position) {
            const positions = {
                'top-left': 'top: 10px; left: 10px; transform: translate(0, 0);',
                'top-center': 'top: 10px; left: 50%; transform: translate(-50%, 0);',
                'top-right': 'top: 10px; right: 10px; transform: translate(0, 0);',
                'center-left': 'top: 50%; left: 10px; transform: translate(0, -50%);',
                'center': 'top: 50%; left: 50%; transform: translate(-50%, -50%);',
                'center-right': 'top: 50%; right: 10px; transform: translate(0, -50%);',
                'bottom-left': 'bottom: 10px; left: 10px; transform: translate(0, 0);',
                'bottom-center': 'bottom: 10px; left: 50%; transform: translate(-50%, 0);',
                'bottom-right': 'bottom: 10px; right: 10px; transform: translate(0, 0);'
            };
            return positions[position] || positions['center'];
        }

        // Get CSS styles for size (preserves aspect ratio)
        function getSizeStyles(size) {
            const sizes = {
                'small': 'max-width: 128px; max-height: 128px; width: auto; height: auto;',
                'medium': 'max-width: 512px; max-height: 512px; width: auto; height: auto;',
                'original': 'max-width: 90%; max-height: 90%; width: auto; height: auto;'
            };
            return sizes[size] || sizes['medium'];
        }

        // Show animated text command
        function showAnimatedTextCommand(commandData) {
            console.log('[OBS] showAnimatedTextCommand called with:', JSON.stringify(commandData, null, 2));
            
            const {
                textContent,
                animationType = 'neon',
                positionX = 960,
                positionY = 540,
                fontSize = 48,
                duration = 5000,
                color1 = '#ff005e',
                color2 = '#00d4ff',
                fontFamily = 'Arial',
                customAnimationIn = null,
                customAnimationOut = null
            } = commandData;

            // Normalize animation type (handles legacy values like "3D")
            const normalizedAnimationType = String(animationType || 'neon').trim().toLowerCase();

            // Build a safe CSS font-family string (quotes fonts like: Press Start 2P)
            function toCssFontFamily(family) {
                const raw = (family && String(family).trim() !== '') ? String(family).trim() : 'Arial';
                // If it contains anything besides letters/digits/space/hyphen/underscore, quote it.
                // Also quote if it contains a digit-starting token (e.g. "2P") which can break unquoted family names.
                const needsQuotes = /[^a-zA-Z0-9 _-]/.test(raw) || /\b\d/.test(raw) || /\s/.test(raw);
                const quoted = needsQuotes ? `"${raw.replace(/"/g, '\\"')}"` : raw;
                return `${quoted}, sans-serif`;
            }
            const cssFontFamily = toCssFontFamily(fontFamily);

            // Use textContent from commandData, or fallback to command name
            const displayText = (textContent && textContent.trim() !== '') 
                ? textContent 
                : (commandData.command || 'Animated Text');
            
            if (!displayText || displayText.trim() === '') {
                console.error('[OBS] No textContent provided in commandData');
                return;
            }

            const container = document.getElementById('animated-text-container');
            if (!container) {
                console.error('[OBS] Animated text container not found!');
                return;
            }

            // Create text element
            const textElement = document.createElement('div');
            textElement.style.cssText = `
                position: absolute;
                left: ${positionX}px;
                top: ${positionY}px;
                transform: translate(-50%, -50%);
                font-size: ${fontSize}px;
                font-family: ${cssFontFamily};
                color: #fff;
                white-space: nowrap;
                pointer-events: none;
                z-index: 10000;
            `;

            if (normalizedAnimationType === 'neon') {
                // Neon text animation
                textElement.className = 'neon-text';
                textElement.textContent = displayText;
                textElement.style.textShadow = `0 0 5px ${color1}, 0 0 10px ${color1}, 0 0 20px ${color1}, 0 0 40px ${color1}, 0 0 80px ${color1}`;
                
                // Add animation keyframes dynamically
                const styleId = 'neon-animation-style';
                if (!document.getElementById(styleId)) {
                    const style = document.createElement('style');
                    style.id = styleId;
                    style.textContent = `
                        @keyframes neon-glow {
                            0% {
                                text-shadow: 0 0 5px ${color1}, 0 0 10px ${color1}, 0 0 20px ${color1}, 0 0 40px ${color1}, 0 0 80px ${color1};
                            }
                            100% {
                                text-shadow: 0 0 10px ${color2}, 0 0 20px ${color2}, 0 0 40px ${color2}, 0 0 80px ${color2}, 0 0 160px ${color2};
                            }
                        }
                        .neon-text {
                            animation: neon-glow 1.5s infinite alternate;
                        }
                    `;
                    document.head.appendChild(style);
                } else {
                    // Update existing style
                    const style = document.getElementById(styleId);
                    style.textContent = `
                        @keyframes neon-glow {
                            0% {
                                text-shadow: 0 0 5px ${color1}, 0 0 10px ${color1}, 0 0 20px ${color1}, 0 0 40px ${color1}, 0 0 80px ${color1};
                            }
                            100% {
                                text-shadow: 0 0 10px ${color2}, 0 0 20px ${color2}, 0 0 40px ${color2}, 0 0 80px ${color2}, 0 0 160px ${color2};
                            }
                        }
                        .neon-text {
                            animation: neon-glow 1.5s infinite alternate;
                        }
                    `;
                }
            } else if (normalizedAnimationType === '3d' || normalizedAnimationType === '3-d') {
                // 3D animated text
                const wantsNabla = String(fontFamily || '').toLowerCase().includes('nabla');
                
                if (wantsNabla) {
                    // Nabla: Use per-letter spans with depth animation (variable font magic)
                    textElement.className = 'animated-text-3d';

                    const h1 = document.createElement('h1');
                    h1.style.margin = '0';
                    h1.style.padding = '0';
                    h1.style.lineHeight = '1';
                    h1.style.fontSize = `${fontSize}px`;
                    h1.style.fontFamily = cssFontFamily;
                    h1.style.color = '#fff';
                    h1.classList.add('nabla-font');
                    textElement.appendChild(h1);

                    // If fonts API is available, warn when Nabla isn't available (OBS/CEF too old)
                    try {
                        if (document.fonts && !document.fonts.check('16px Nabla')) {
                            console.warn('[OBS] Nabla font not available yet (or unsupported by this OBS/CEF). If it never renders, update OBS to a newer version.');
                        }
                    } catch (e) {
                        // ignore
                    }

                    const chars = displayText.split('');
                    chars.forEach((char, index) => {
                        if (char === ' ') {
                            h1.appendChild(document.createTextNode(' '));
                            return;
                        }
                        const span = document.createElement('span');
                        span.textContent = char;
                        span.style.animationDelay = `${index * 0.1}s`;
                        h1.appendChild(span);
                    });
                } else {
                    // Non-Nabla fonts: Use whole text with stacked shadows for actual 3D look
                    textElement.className = 'animated-text-3d-solid';

                    const h1 = document.createElement('h1');
                    h1.textContent = displayText;
                    h1.style.margin = '0';
                    h1.style.padding = '0';
                    h1.style.lineHeight = '1';
                    h1.style.fontSize = `${fontSize}px`;
                    h1.style.fontFamily = cssFontFamily;
                    h1.style.color = '#fff';
                    h1.style.fontWeight = 'bold';
                    // Stacked text-shadow for 3D depth effect
                    h1.style.textShadow =
                        '0 1px 0 #ccc, 0 2px 0 #c9c9c9, 0 3px 0 #bbb, 0 4px 0 #b9b9b9, 0 5px 0 #aaa, 0 6px 1px rgba(0,0,0,.1), 0 0 5px rgba(0,0,0,.1), 0 1px 3px rgba(0,0,0,.3), 0 3px 5px rgba(0,0,0,.2), 0 5px 10px rgba(0,0,0,.25), 0 10px 10px rgba(0,0,0,.2), 0 20px 20px rgba(0,0,0,.15)';
                    textElement.appendChild(h1);
                }
            } else if (normalizedAnimationType === 'block') {
                // Text Block (wipe) animation – loops automatically (no hover)
                const block = document.createElement('div');
                block.className = 'text-block';
                block.style.setProperty('--tb-accent', color1);
                block.style.setProperty('--tb-secondary', color2 || '#ffffff');
                // Cycle time: try to be proportional to visible duration (but bounded)
                const cycle = Math.max(1200, Math.min(4000, Math.floor(duration / 2)));
                block.style.setProperty('--tb-cycle', `${cycle}ms`);

                const h1 = document.createElement('h1');
                h1.textContent = displayText;
                h1.style.fontFamily = cssFontFamily;
                h1.style.fontSize = `${fontSize}px`;
                block.appendChild(h1);

                // Use the block as the child of the positioned wrapper
                textElement.style.fontFamily = 'inherit';
                textElement.style.color = '#fff';
                textElement.style.whiteSpace = 'nowrap';
                textElement.appendChild(block);
            } else if (normalizedAnimationType === 'custom') {
                // Create Your Own: plain text (motion handled by animate.css)
                textElement.className = 'custom-text';
                textElement.textContent = displayText;
                textElement.style.fontFamily = cssFontFamily;
                // Use primary color as text color for custom mode
                textElement.style.color = color1 || '#ffffff';
            } else {
                // Unknown type: fall back to neon so something always shows
                console.warn('[OBS] Unknown animationType, falling back to neon:', animationType);
                textElement.className = 'neon-text';
                textElement.textContent = displayText;
                textElement.style.textShadow = `0 0 5px ${color1}, 0 0 10px ${color1}, 0 0 20px ${color1}, 0 0 40px ${color1}, 0 0 80px ${color1}`;
            }

            // If animate.css classes are provided, use them; otherwise use our transition system
            const hasAnimateIn = !!(customAnimationIn && String(customAnimationIn).trim() !== '');
            const hasAnimateOut = !!(customAnimationOut && String(customAnimationOut).trim() !== '');
            const useAnimateCss = hasAnimateIn || hasAnimateOut;

            const transition = useAnimateCss ? null : buildAnimatedTextTransition(commandData);
            if (transition) {
                transition.applyInitial(textElement);
            }

            container.appendChild(textElement);
            console.log('[OBS] Animated text element added to container', {
                useAnimateCss,
                transitionPreset: transition?.preset,
                inMs: transition?.inMs,
                outMs: transition?.outMs,
                customAnimationIn,
                customAnimationOut
            });

            // Play-in after append
            if (useAnimateCss) {
                // animate.css uses these CSS variables for timing
                // https://github.com/animate-css/animate.css
                textElement.style.setProperty('--animate-duration', `${Math.max(0, parseInt(commandData?.transitionInMs || 250, 10) || 250)}ms`);
                textElement.classList.add('animate__animated');
                if (hasAnimateIn) {
                    textElement.classList.add(String(customAnimationIn).trim());
                }
            } else {
                transition.playIn(textElement);
            }

            // Remove text after duration, but animate out first
            const outMs = useAnimateCss
                ? Math.max(0, parseInt(commandData?.transitionOutMs || 400, 10) || 400)
                : (transition?.outMs || 400);

            setTimeout(() => {
                console.log('[OBS] Removing animated text after duration (with animation)');

                if (useAnimateCss) {
                    // swap in -> out (if provided)
                    textElement.style.setProperty('--animate-duration', `${outMs}ms`);

                    if (hasAnimateIn) {
                        textElement.classList.remove(String(customAnimationIn).trim());
                    }
                    if (hasAnimateOut) {
                        textElement.classList.add(String(customAnimationOut).trim());
                    } else {
                        // fallback if only "in" was provided
                        textElement.style.transition = `opacity ${outMs}ms ease`;
                        textElement.style.opacity = '0';
                    }

                    setTimeout(() => {
                        if (textElement.parentNode) {
                            textElement.parentNode.removeChild(textElement);
                            console.log('[OBS] Animated text removed');
                        }
                    }, outMs + 50);
                    return;
                }

                const exitDuration = transition?.startExit ? transition.startExit(textElement) : outMs;
                setTimeout(() => {
                    if (textElement.parentNode) {
                        textElement.parentNode.removeChild(textElement);
                        console.log('[OBS] Animated text removed');
                    }
                }, (exitDuration || outMs) + 25);
            }, Math.max(0, duration - outMs));
        }

        // Preload audio files (optional - can be enabled if needed)
        async function preloadAudioFiles() {
            // This could fetch the list of commands and preload them
            // For now, we'll load them on-demand
        }

        // Decode HTML entities (for &quot; etc.)
        function decodeHtmlEntities(str) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = str;
            return textarea.value;
        }

        // Load and render design elements
        function loadDesignElements(designDataStr) {
            let designElements = [];
            
            try {
                // If designDataStr is provided (from WebSocket update), use it first
                // Otherwise, fall back to window variable (from initial page load)
                if (designDataStr && designDataStr !== '{{DESIGN_DATA}}' && designDataStr !== '[]' && designDataStr.trim() !== '') {
                    // Decode HTML entities if needed (handles &quot; etc.)
                    let decoded = designDataStr;
                    try {
                        decoded = decodeHtmlEntities(designDataStr);
                    } catch (e) {
                        // If decodeHtmlEntities fails, try parsing directly
                        decoded = designDataStr;
                    }
                    
                    // Parse JSON
                    if (typeof decoded === 'string') {
                        designElements = JSON.parse(decoded);
                    } else {
                        designElements = Array.isArray(decoded) ? decoded : [];
                    }
                    console.log('[OBS] Loaded design elements from WebSocket update:', designElements.length);
                } 
                // Fall back to window variable (from initial page load) if no WebSocket data
                else if (window.__OBS_DESIGN_DATA__) {
                    designElements = Array.isArray(window.__OBS_DESIGN_DATA__) 
                        ? window.__OBS_DESIGN_DATA__ 
                        : JSON.parse(window.__OBS_DESIGN_DATA__);
                    console.log('[OBS] Loaded design elements from window variable:', designElements.length);
                } else {
                    console.log('[OBS] No design data found');
                }
            } catch (error) {
                console.error('[OBS] Error parsing design data:', error);
                console.error('[OBS] Design data string:', designDataStr);
                console.error('[OBS] Window data:', window.__OBS_DESIGN_DATA__);
                console.error('[OBS] Error details:', error.message);
            }
            
            const container = document.getElementById('design-container');
            if (!container) return;
            
            // Clear existing elements
            container.innerHTML = '';
            
            if (designElements.length === 0) {
                return; // No design elements to render
            }
            
            // Render each design element
            designElements.forEach((elementData) => {
                // Handle both old percentage format and new 1080p format
                let x1080p, y1080p, width1080p, height1080p;
                const OBS_CANVAS_WIDTH = 1920;
                const OBS_CANVAS_HEIGHT = 1080;
                
                if (elementData.x > 100) {
                    // New format: 1080p coordinates (pixels)
                    x1080p = elementData.x;
                    y1080p = elementData.y;
                    width1080p = elementData.width;
                    height1080p = elementData.height;
                } else {
                    // Old format: percentages (convert to 1080p)
                    x1080p = (elementData.x / 100) * OBS_CANVAS_WIDTH;
                    y1080p = (elementData.y / 100) * OBS_CANVAS_HEIGHT;
                    width1080p = elementData.width;
                    height1080p = elementData.height;
                }
                
                // Use pixel positioning directly (no percentage conversion needed)
                // x1080p and y1080p are already in pixels for 1920x1080 canvas
                
                let element;
                
                if (elementData.type === 'text') {
                    element = document.createElement('div');
                    element.textContent = elementData.text || '';
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        padding: 10px 20px;
                        background: rgba(255, 255, 255, 0.2);
                        backdrop-filter: blur(10px);
                        border: 2px solid rgba(255, 255, 255, 0.3);
                        border-radius: 8px;
                        color: ${elementData.color || '#ffffff'};
                        font-size: ${elementData.fontSize || 24}px;
                        font-weight: bold;
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        text-align: center;
                        box-sizing: border-box;
                    `;
                } else if (elementData.type === 'image') {
                    element = document.createElement('img');
                    element.src = elementData.imagePath;
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        object-fit: contain;
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        box-sizing: border-box;
                    `;
                } else if (elementData.type === 'circle' || elementData.type === 'square') {
                    element = document.createElement('div');
                    const isCircle = elementData.type === 'circle';
                    const borderRadius = isCircle ? 'border-radius: 50%;' : '';
                    element.style.cssText = `
                        position: absolute;
                        left: ${x1080p}px;
                        top: ${y1080p}px;
                        width: ${width1080p}px;
                        height: ${height1080p}px;
                        ${borderRadius}
                        background: ${elementData.color || 'rgba(255, 100, 100, 0.5)'};
                        border: 2px solid rgba(255, 255, 255, 0.5);
                        pointer-events: none;
                        transform: translate(0, 0) rotate(${elementData.rotation || 0}deg);
                        z-index: ${elementData.zIndex || 10};
                        box-sizing: border-box;
                    `;
                }
                
                if (element) {
                    container.appendChild(element);
                }
            });
            
            console.log(`[OBS] Rendered ${designElements.length} design elements`);
        }

        // Initialize
        connect();
        
        // Load initial design elements
        // The server embeds design data in window.__OBS_DESIGN_DATA__
        loadDesignElements();
    </script>
</body>
</html>

